### 从输入url到页面打开过程

1. 用户输入
用户输入并回车，当前页面即将被替换成新的页面。在这之前，浏览器给当前页面一次执行 **beforeunload** 事件的机会，**beforeunload** 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页
```js
window.addEventListener('beforeunload',function () {

})
// addEventListener 第三个参数
/**
可选。布尔值，指定事件是否在捕获或冒泡阶段执行。

可能值:
true - 事件句柄在捕获阶段执行
false- false- 默认。事件句柄在冒泡阶段执行
*/
```

2. 用户输入url，浏览器会根据用户输入的信息判断是搜索还是网址；如果是搜索内容，就将搜索内容+默认搜索引擎合成新的url；
如果用户输入的内容符合url规则，浏览器会根据url协议，在这段内容上内容上加上协议合成合法的url。


### DNS域名解析
DNS 服务器是高可用、高并发和分布式的，它是树状结构
![](https://raw.githubusercontent.com/LuckyWinty/blog/master/images/broswer/1580300339022.jpg)
- 根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址
- 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址
- 权威 DNS 服务器 ：返回相应主机的 IP 地址
DNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式是迭代查询；
![](https://raw.githubusercontent.com/LuckyWinty/blog/master/images/broswer/1580310912169.jpg)

![](https://raw.githubusercontent.com/LuckyWinty/blog/master/images/broswer/1580311229864.jpg)
    - DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。
    - 在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。

### 三次握手

- 进行三次握手，建立TCP连接。

- 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；

- 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；

- 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

### SSL握手过程

- 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
- 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
- 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
- 第四阶段 变更密码构件和结束握手协议
完成了之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：

### 关闭TCP连接
- 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

- 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我"同意"你的关闭请求；

- 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；

- 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

2. url 请求过程
- 网络进程会查找本地缓存是否缓存了该资源。
    1. 浏览器缓存
    2. 直接查找
- 未缓存资源，进入网络请求流程。
    1. DNS解析，以获取请求域名的服务器IP地址。如果请求的是HTTPS协议，还需要建立TLS连接
        - DNS缓存：浏览器缓存、hosts 文件
        - 如果本地域名解析服务器也没有该域名的记录，开始递归+迭代解析
        - TCP三次握手，HTTP。TLS握手，HTTPS。
        
- IP地址和服务器建立TCP连接后，浏览器端会构建请求行、请求头等信息，并把该域名相关的cookie等数据附近到请求头中，然后向服务器发送构建的请求信息。
- 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用是将请求合理分发到多台服务器上。服务器会响应一个HTML文件

- 浏览器判断状态码。200 -> 继续解析。400 或者 500 -> 报错。 300 -> 重定向，这里有重定向计数器，避免多次重定向，重定向多次会报错

- 浏览器开始解析文件，如果是gzip文件会先解压，然后通过文件的编码格式知道该如何去解码文件。

3. 准备渲染进程
chrome会为每个页面分配一个渲染进程

4. 渲染阶段
先根据HTML构建DOM树，有CSS的话会构建CSSOM树。如果有script标签，会判断是否存在 async 或者 defer
- async 并行下载并执行JS
- defer 先下载文件，等待HTML解析完成后顺序执行
- 都没有，阻塞渲染流程直到 JS 执行完毕

##### 普通script标签
```html
<script src="a.js"/>
```
- 停止解析document
- 请求a.js
- 执行a.js中的脚本
- 继续解析document

##### defer
```html
<script src="b.js" defer></script>
<script src="e.js" defer></script>
```
- 不阻止解析 document， 并行下载 d.js, e.js
- 即使下载完 d.js, e.js 仍继续解析 document
- 按照页面中出现的顺序，在其他同步脚本执行后，DOMContentLoaded 事件前 依次执行 d.js, e.js。

##### async
```html
<script src="b.js" async></script>
<script src="c.js" async></script>
```
- 不阻止解析 document, 并行下载 b.js, c.js
- 当脚本下载完后立即执行。（两者执行顺序不确定，执行阶段不确定，可能在 DOMContentLoaded 事件前或者后 ）

CSSOM树 和 DOM树构建完成后会开始生成render树，确定页面元素的布局，样式等

在生成render树的过程中，浏览器开始调用GPU绘制，合成图层。


### 页面打开过程
DOMContentLoaded event 首屏渲染
window:load event 页面加载完成
页面打开过程中依次触发了 DOMContentLoaded -> First Paint -> First Contentful Paint -> Onload Event -> First Meaningful Paint

- DOMContentLoaded 
HTML加载解析完成后触发。浏览器尚未开始渲染，其他静态资源，图片等还未加载
- First Paint, First Contentful Paint。
用户开始看到文字。此时图片尚未加载回来，所以还不能看到图片
-  onLoad Event 
浏览器把图片加载回来了，所有资源都加载完成
- First Meaningful Paint
异步请求回来，页面DOM更新，触发First Meaningful Paint

### 浏览器基础
- 在接收到用户输入的网址后，浏览器会开启一个线程来处理这个请求，对用户输入的url地址进行分析判断，如果是HTTP协议就按照HTTP方式来处理。
- 调用浏览器引擎中的对应方法，比如webview中的loadUrl方法，分析并加载这个url地址。
- 通过DNS解析获取该网站地址对应的IP，查完后连同浏览器的cookie、userAgent等信息向网站目的IP发出GET请求。
- 进行HTTP协议会话，浏览器客户端向Web服务器发送报文。
- 进入网站后台上的web服务器处理请求，如Apache/Tomcat/Nodejs等服务器。
- 进入部署好的后端应用，如PHP、等后端程序，找到对应的请求处理逻辑，这期间可能会读取服务器缓存或查询数据库等。
- 服务器处理请求并返回响应报文，此时如果浏览器访问过该页面，缓存上有对应资源，会与服务器最后修改记录对比，一致返回304
- 浏览器开始下载HTML文档，或者从本地缓存读取文件内容。
- 浏览器根据下载接收到的HTML文件解析解构建立DOM文档树，并根据HTML中的标记请求下载指定的MIME类型文件。同时设置缓存等内容。
- 页面开始解析渲染DOM，CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染，JavaScript根据DOM API操作DOM，并读取浏览器缓存、执行事件绑定等，页面整个展示过程完成。

### 浏览器组成
- 用户界面
- 网络
- JavaScript引擎
- 渲染引擎
- UI后端
- JavaScript解释器
- 持久化数据存储

浏览器引擎可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据。是浏览器中各个部分之间相互通信的核心。
浏览器渲染引擎的功能是解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，我们常说的浏览器内核主要指的是渲染引擎。
JavaScript解释器是浏览器解析和执行JavaScript脚本的部分，例如V8引擎。


### 页面资源加载
当浏览器截获到一个页面请求后。
1. 首先将所有需要加载的资源进行分类
2. 根据浏览器相关的安全策略，来决定资源的加载权限
3. 对各个资源的加载优先级进行计算和排序
4. 根据加载优先级排序资源

#### 第一步资源分类
|类型|介绍|
|kMainResource|即主资源，html页面文件资源就属于该类型|
|kImage|各种图片资源|
|kCSSStyleSheet|顾名思义，就是层叠样式表css资源|
|kScript|脚本资源，例如js资源|
|kFont|字体资源，例如网页中常用的字体集.woff资源|
|kRaw|混合类型资源，最常见的ajax请求就属于这类资源|
|kSVGDocument|SVG可缩放矢量图形文件资源|
|kXSLStyleSheet|扩展样式表语言XSLT，是一种转换语言，关于该类型可以查阅w3c XSL来了解|
|kLinkPrefetch|HTML5页面的预读取资源(Link prefetch)，例如dns-prefetch。下面会有详细介绍|
|kTextTrack|video的字幕资源，- 即<track>标签|
|kImportResource|HTML Imports，将一个HTML文件导入到其他HTML文档中，例如<link href="import/post.html" rel="import" />。详细了解请查阅相关文档。|
|kMedia|多媒体资源，video or audio都属于该类资源|
|kManifest|HTML5 应用程序缓存资源|
|kMock|预留的测试类型|

#### 第二部安全策略检测
网页安全政策（Content Security Policy，缩写 CSP）是由浏览器提供的一种白名单制度。
开发者通过配置，来告诉浏览器各类外部资源的加载和执行限制，来提高网页的安全性。一种最常用的应用就是通过限制非信任域名脚本的加载来预防XSS攻击。
可以通过两种方式来配置CSP。
第一种，就是通过页面HTTP请求头的Content-Security-Policy字段来限制

第二种是，通过<meta>标签来设置。<meta>是以key-value的方式来进行配置的。
1. 用于预防XSS
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'; style-src nos.netease.com kaola.com;">
```
上面的script-src代表脚本资源；style-src代表样式资源；'self'代表只信任当前域名下的外来资源，其他域下的资源全部会被拦截；nos.netease.com kaola.com代表信任nos.netease.com和kaola.com这两个域名下的资源。
所以上面的标签的意义就是：对于脚本资源只信任本域下的，对于样式资源，除了本域还会加载nos.netease.com和kaola.com这两个域名下的。

2. 用于站点请求协议升级过渡（http转https）
```html
<meta http-equiv="Content-Secur****ity-Policy" content="upgrade-insecure-requests">
```
上面的upgrade-insecure-requests的意义，就如同字面意思一样：升级所有非安全请求。当加了这个meta标签以后，浏览器会将https页面中的所有htttp请自动升级到https。

3. 用于阻止Mixed Content
```html
<meta http-equiv="Content-Security-Policy" content="block-all-mixed-content">
```
在https站点中，进行的http请求。这类在安全链接中混合了非安全请求内容就叫混合内容。出现这类请求时，我们可以在浏览器控制台中找到对应的警告信息
混合内容会降低HTTPS网站的安全性和用户体验。不过让人略感放心的是，浏览器对于可能对安全性造成较大威胁的资源类型的混合模式请求都会直接拦截报错，例如脚本资源。但对于图片、音频、视频等资源只会警告，但不会阻止其加载

### 优化关键请求链
利用preload 
```html
<link rel="preload" href="">
```
利用prefetch
```html
资源预加载：<link rel="prefetch" href="xxx.css">
DNS预解析：<link rel="dns-prefetch" href="//xxx.com">
HTTP预连接：<link rel="prefetch" href="xxx.com">
页面预渲染：<link rel="prerender" href="xxx.com">
```

Preload来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级.对于那些本来请求优先级较低的关键请求，我们可以通过设置Prefetch来提升这些请求的优先级.
Prefetch来告诉浏览器用户将来可能在其他页面（非本页面）可能使用到的资源，那么浏览器会在空闲时，就去预先加载这些资源放在http缓存内，最常见的dns-prefetch。
当我们在浏览A页面，如果会通过A页面中的链接跳转到B页面，而B页面中我们有些资源希望尽早提前加载，那么我们就可以在A页面里添加这些资源Prefetch，那么当浏览器空闲时，就会去加载这些资源。 


#### 资源优先级计算
浏览器资源优先级计算过程：
- 第一步，根据资源的类型来设定默认优先级。 对于每一类资源浏览器都有一个默认的加载优先级规则：
1. HTML、css、font这三种类型的资源优先级最高。
2. preload资源 （通过<link rel="preload">标签预加载）、script、xhr请求
3. 图片、语音、视频
4. 最低的是prefetch预读取的资源

- 第二步，根据一定的实际规则，对优先级进行调整。 初始优先级设置好以后，浏览器会根据资源的实际属性和位于文档中的位置等方面，对优先级进行调整，来确定出最终的加载优先级顺序。

1. 对于XHR请求资源：将同步XHR请求的优先级调整为最高，XHR请求分为同步请求和异步请求
2. 对于图片资源：会根据图片是否在可见视图之内来改变优先级。现代浏览器为了提高用户首屏的体验，在渲染时会计算图片资源是否在首屏可见视图之内
3. 脚本资源：浏览器会将根据脚本所处的位置和属性标签分为三类。对于添加了defer/async属性标签的脚本的优先级会全部降为Low。对于没有添加该属性的脚本，根据该脚本在文档中的位置是在浏览器展示的第一张图片之前还是之后，又可分为两类。在之前的(标记early**)它会被定为High优先级，在之后的(标记late**)会被设置为Medium优先级。


 



